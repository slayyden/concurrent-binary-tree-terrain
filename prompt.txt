is there a difference between these rust and slang functions. the rust function is correct. the slang function may not be.

#include "cbt.slang"
// Lookup table mapping split command + edge index => edge slots

static const uint2 COMMAND_EDGE_LUT[4][3] = {
    // CENTRAL_SPLIT
    { uint2(0, 0), uint2(1, 1), uint2(1, 0) },
    // RIGHT_DOUBLE_SPLIT
    { uint2(2, 0), uint2(1, 1), uint2(1, 2) },
    // LEFT_DOUBLE_SPLIT
    { uint2(0, 0), uint2(2, 1), uint2(1, 0) },
    // TRIPLE_SPLIT
    { uint2(2, 0), uint2(3, 1), uint2(1, 2) }
};


// Given a split command and an edge index (NEXT, PREV, or TWIN)
// Return up to two allocation slots that touch each half of the edge
// If the edge has not been split, these slots will be the same
// The first slot appears on the left when viewing the triangle from the outside
// with the specified edge at the bottom and its opposing vertex at the top
uint2 get_edge_slots(uint command, uint edge_type)
{
    if (command == 0) // NO_SPLIT
        return uint2(0, 0);
    return COMMAND_EDGE_LUT[command >> 1][edge_type];
}

// Child edge type LUT
static const uint2 CHILD_EDGE_TYPE_LUT[4][3] = {
    // CENTRAL_SPLIT
    { uint2(TWIN, TWIN), uint2(TWIN, TWIN), uint2(NEXT, PREV) },
    // RIGHT_DOUBLE_SPLIT
    { uint2(NEXT, PREV), uint2(TWIN, TWIN), uint2(NEXT, TWIN) },
    // LEFT_DOUBLE_SPLIT
    { uint2(TWIN, TWIN), uint2(NEXT, PREV), uint2(TWIN, PREV) },
    // TRIPLE_SPLIT
    { uint2(NEXT, PREV), uint2(NEXT, PREV), uint2(TWIN, TWIN) }
};

// Given a split command and a parent edge type,
// return the types of the childrenâ€™s edges corresponding to that edge
uint2 get_child_edge_types(uint command, uint parent_edge_type)
{
    return CHILD_EDGE_TYPE_LUT[command >> 1][parent_edge_type];
}

// Link sibling edges by updating their neighbor buffer entries
void link_siblings(uint prev_sibling, uint next_sibling)
{
    pc.scene.neighbors_buffer[prev_sibling][NEXT] = next_sibling;
    pc.scene.neighbors_buffer[next_sibling][PREV] = prev_sibling;
}

[shader("compute")]
[numthreads(WORKGROUP_SIZE, 1, 1)]
void update_pointers(
    int3 tid: SV_DispatchThreadID)
{

    if (tid.x >= pc.dispatch.splitting_buffer_count.load())
    {
        return;
    }
    let curr_id = pc.scene.splitting_buffer[tid.x];
    let heap_id_buffer = pc.scene.heapid_buffer;
    let allocation_indices_buffer = pc.scene.allocation_indices_buffer;
    let bisector_command_buffer = pc.scene.bisector_split_command_buffer;
    let neighbor_buffer = pc.scene.neighbors_buffer;
    uint curr_heapid = heap_id_buffer[curr_id];
    uint curr_command = bisector_command_buffer[curr_id];

    uint3 neighbors = neighbor_buffer[curr_id];
    uint4 curr_allocation_indices = allocation_indices_buffer[curr_id];

    // Loop over each edge (NEXT, PREV, TWIN)
    for (uint bisector_edge_idx = 0; bisector_edge_idx < 3; ++bisector_edge_idx)
    {
        uint neighbor_index = neighbors[bisector_edge_idx];
        uint2 bisector_slots = get_edge_slots(curr_command, bisector_edge_idx);
        uint2 edge_types = get_child_edge_types(curr_command, bisector_edge_idx);

        uint slot = curr_allocation_indices[bisector_slots[0]];
        uint edge_type = edge_types[0];

        uint4 neighbor_allocation_indices = uint4(0xFFFFFFFF);
        uint neighbor_slot = 0xFFFFFFFF;
        uint2 neighbor_slots = uint2(0, 0);

        if (neighbor_index != 0xFFFFFFFF)
        {
            uint neighbor_command = bisector_command_buffer[neighbor_index];
            uint neighbor_edge = find_edge_type(curr_id, neighbor_buffer[neighbor_index]);

            if (neighbor_command == 0)
            { // NO_SPLIT
                if (curr_id != slot)
                {
                    neighbor_buffer[neighbor_index][neighbor_edge] = slot;
                }
                neighbor_slot = neighbor_index;
            }
            else
            {
                neighbor_allocation_indices = allocation_indices_buffer[neighbor_index];
                neighbor_slots = get_edge_slots(neighbor_command, neighbor_edge);
                neighbor_slot = neighbor_allocation_indices[neighbor_slots[1]];
            }
        }

        neighbor_buffer[slot][edge_type] = neighbor_slot;

        if (bisector_slots[0] != bisector_slots[1])
        {
            uint slot2 = curr_allocation_indices[bisector_slots[1]];
            uint edge_type2 = edge_types[1];
            uint neighbor_slot2 = neighbor_allocation_indices[neighbor_slots[0]];
            neighbor_buffer[slot2][edge_type2] = neighbor_slot2;
        }
    }

    // Write intra-bisector pointers and heap IDs
    if (curr_command == CENTER_SPLIT)
    {
        link_siblings(curr_allocation_indices[0], curr_allocation_indices[1]);
        heap_id_buffer[curr_allocation_indices[1]] = 2 * curr_heapid + 0;
        heap_id_buffer[curr_allocation_indices[0]] = 2 * curr_heapid + 1;
    }
    else if (curr_command == RIGHT_DOUBLE_SPLIT)
    {
        link_siblings(curr_allocation_indices[0], curr_allocation_indices[2]);
        neighbor_buffer[curr_allocation_indices[0]][TWIN] = curr_allocation_indices[1];
        neighbor_buffer[curr_allocation_indices[1]][PREV] = curr_allocation_indices[0];

        heap_id_buffer[curr_allocation_indices[1]] = 2 * curr_heapid;
        heap_id_buffer[curr_allocation_indices[2]] = 4 * curr_heapid + 2;
        heap_id_buffer[curr_allocation_indices[0]] = 4 * curr_heapid + 3;
    }
    else if (curr_command == LEFT_DOUBLE_SPLIT)
    {
        link_siblings(curr_allocation_indices[1], curr_allocation_indices[2]);
        neighbor_buffer[curr_allocation_indices[2]][TWIN] = curr_allocation_indices[0];
        neighbor_buffer[curr_allocation_indices[0]][NEXT] = curr_allocation_indices[2];

        heap_id_buffer[curr_allocation_indices[0]] = 2 * curr_heapid + 1;
        heap_id_buffer[curr_allocation_indices[2]] = 4 * curr_heapid + 0;
        heap_id_buffer[curr_allocation_indices[1]] = 4 * curr_heapid + 1;
    }
    else
    {
        // TRIPLE_SPLIT
        link_siblings(curr_allocation_indices[1], curr_allocation_indices[3]);
        link_siblings(curr_allocation_indices[0], curr_allocation_indices[2]);
        neighbor_buffer[curr_allocation_indices[3]][TWIN] = curr_allocation_indices[0];
        neighbor_buffer[curr_allocation_indices[0]][TWIN] = curr_allocation_indices[3];

        heap_id_buffer[curr_allocation_indices[3]] = 4 * curr_heapid + 0;
        heap_id_buffer[curr_allocation_indices[1]] = 4 * curr_heapid + 1;
        heap_id_buffer[curr_allocation_indices[2]] = 4 * curr_heapid + 2;
        heap_id_buffer[curr_allocation_indices[0]] = 4 * curr_heapid + 3;
    }

    // Clear current bit and set new ones
    unset_bit(curr_id);
    for (int i = 0; i < 4; ++i)
    {
        if (curr_allocation_indices[i] != INVALID_INDEX)
        {
            set_bit(curr_allocation_indices[i]);
        }
    }
}

here is a reference rust version:

pub fn update_pointers(
    curr_id: u32,
    neighbor_buffer: &mut [[u32; 3]],
    heap_id_buffer: &mut [u32],
    bisector_command_buffer: &[AtomicU32],
    allocation_indices_buffer: &[[u32; 4]],
    cbt: &mut CBT,
) {
    let curr_heapid = heap_id_buffer[curr_id as usize];
    let curr_command = bisector_command_buffer[curr_id as usize].load(Ordering::Relaxed);
    debug_assert!(curr_command != NO_SPLIT);
    let neighbors = neighbor_buffer[curr_id as usize];

    let curr_allocation_indices = allocation_indices_buffer[curr_id as usize];

    // iterate over EDGES of the parent bisector that is being split
    for (bisector_edge_idx, neighbor_index) in neighbors.into_iter().enumerate() {
        // boundary edge, write child pointers and we're done

        let bisector_slots = get_edge_slots(curr_command, bisector_edge_idx); // 0
        let edge_types = get_child_edge_types(curr_command, bisector_edge_idx); // TWIN

        // write external pointers for first allocated slot
        let slot = curr_allocation_indices[bisector_slots[0] as usize] as usize; // 1
        let edge_type = edge_types[0] as usize; // TWIN
        // defaults if the neighbor does not exist
        let mut neighbor_allocation_indices = [u32::MAX, u32::MAX, u32::MAX, u32::MAX];
        let mut neighbor_slot = u32::MAX;
        let mut neighbor_slots = [0, 0];
        // the neighbor exists. find the slot in the neighbor adjacent to the first slot in the current bisector
        if neighbor_index != u32::MAX {
            let neighbor_command =
                bisector_command_buffer[neighbor_index as usize].load(Ordering::Relaxed);
            let neighbor_edge = find_edge_type(curr_id, neighbor_buffer[neighbor_index as usize]);
            if neighbor_command == NO_SPLIT {
                // non-split tris are not dispatched, so we update them as well
                // neighbor_buffer[neighbor_index] == curr_index by construction
                if curr_id != slot as u32 {
                    neighbor_buffer[neighbor_index as usize][neighbor_edge] = slot as u32;
                }
                neighbor_slot = neighbor_index;
            } else {
                neighbor_allocation_indices = allocation_indices_buffer[neighbor_index as usize];
                neighbor_slots = get_edge_slots(neighbor_command, neighbor_edge);
                neighbor_slot = neighbor_allocation_indices[neighbor_slots[1] as usize]; // left and right are flipped from the neighbor's perspective
            }
        }

        neighbor_buffer[slot][edge_type] = neighbor_slot;

        // this edge was split, write pointers to the second child
        if bisector_slots[0] != bisector_slots[1] {
            let slot = curr_allocation_indices[bisector_slots[1] as usize] as usize;
            let edge_type = edge_types[1] as usize;
            let neighbor_slot = neighbor_allocation_indices[neighbor_slots[0] as usize];

            neighbor_buffer[slot][edge_type] = neighbor_slot;
        }
    }

    // update pointers from bisector children to other bisector children
    // also writes new heapids
    // best to draw a picture for this
    // TODO: reduce branched global stores
    if curr_command == CENTER_SPLIT {
        link_siblings(
            curr_allocation_indices[0],
            curr_allocation_indices[1],
            neighbor_buffer,
        );

        // LEFT child must have the LOWER heapid
        // left child
        heap_id_buffer[curr_allocation_indices[1] as usize] = 2 * curr_heapid + 0;
        // right child
        heap_id_buffer[curr_allocation_indices[0] as usize] = 2 * curr_heapid + 1;
    } else if curr_command == RIGHT_DOUBLE_SPLIT {
        link_siblings(
            curr_allocation_indices[0],
            curr_allocation_indices[2],
            neighbor_buffer,
        );
        neighbor_buffer[curr_allocation_indices[0] as usize][TWIN] = curr_allocation_indices[1];
        neighbor_buffer[curr_allocation_indices[1] as usize][PREV] = curr_allocation_indices[0];

        // L
        heap_id_buffer[curr_allocation_indices[1] as usize] = 2 * curr_heapid;
        // RL
        heap_id_buffer[curr_allocation_indices[2] as usize] = 4 * curr_heapid + 2;
        // RR
        heap_id_buffer[curr_allocation_indices[0] as usize] = 4 * curr_heapid + 3;
    } else if curr_command == LEFT_DOUBLE_SPLIT {
        link_siblings(
            curr_allocation_indices[1],
            curr_allocation_indices[2],
            neighbor_buffer,
        );
        neighbor_buffer[curr_allocation_indices[2] as usize][TWIN] = curr_allocation_indices[0];
        neighbor_buffer[curr_allocation_indices[0] as usize][NEXT] = curr_allocation_indices[2];

        // R
        heap_id_buffer[curr_allocation_indices[0] as usize] = 2 * curr_heapid + 1;
        // LL
        heap_id_buffer[curr_allocation_indices[2] as usize] = 4 * curr_heapid;
        // LR
        heap_id_buffer[curr_allocation_indices[1] as usize] = 4 * curr_heapid + 1;
    } else {
        debug_assert!(curr_command == TRIPLE_SPLIT);
        link_siblings(
            curr_allocation_indices[1],
            curr_allocation_indices[3],
            neighbor_buffer,
        );
        link_siblings(
            curr_allocation_indices[0],
            curr_allocation_indices[2],
            neighbor_buffer,
        );
        neighbor_buffer[curr_allocation_indices[3] as usize][TWIN] = curr_allocation_indices[0];
        neighbor_buffer[curr_allocation_indices[0] as usize][TWIN] = curr_allocation_indices[3];

        // LL
        heap_id_buffer[curr_allocation_indices[3] as usize] = 4 * curr_heapid + 0;
        // LR
        heap_id_buffer[curr_allocation_indices[1] as usize] = 4 * curr_heapid + 1;
        // RL
        heap_id_buffer[curr_allocation_indices[2] as usize] = 4 * curr_heapid + 2;
        // RR
        heap_id_buffer[curr_allocation_indices[0] as usize] = 4 * curr_heapid + 3;
    }
    cbt.unset_bit(curr_id);
    for i in curr_allocation_indices {
        if i != u32::MAX {
            cbt.set_bit(i);
        }
    }
}

const COMMAND_EDGE_LUT: [[[u8;
        2 /* number of slots going to an edge */];
        3 /* number of edges */];
        4 /*number of potential commmands */]
= [
    // CENTRAL_SPLIT
    [[0, 0], [1, 1], [1, 0]],
    // RIGHT_DOUBLE_SPLIT
    [[2, 0], [1, 1], [1, 2]],
    // LEFT_DOUBLE_SPLIT
    [[0, 0], [2, 1], [1, 0]],
    // TRIPLE_SPLIT
    [[2, 0], [3, 1], [1, 2]],
];

// given a split command and an edge index (NEXT, PREV, or TWIN)
// return up to the allocation slots that touch each half of the edge
// if the edge has not been split, these slots will be the same
// the first slot appears on the left when viewing the triangle from the outside
// with the specified edge at the bottom and its opposing vertex at the top
pub fn get_edge_slots(command: u32, edge_type: usize) -> [u8; 2] {
    debug_assert!(
        command == NO_SPLIT
            || command == CENTER_SPLIT
            || command == RIGHT_DOUBLE_SPLIT
            || command == LEFT_DOUBLE_SPLIT
            || command == TRIPLE_SPLIT,
    );
    debug_assert!(edge_type == NEXT || edge_type == PREV || edge_type == TWIN);
    if command == NO_SPLIT {
        return [0, 0];
    }
    return COMMAND_EDGE_LUT[(command / 2) as usize][edge_type as usize];
}

const NEXT_U8: u8 = 0;
const PREV_U8: u8 = 1;
const TWIN_U8: u8 = 2;
const CHILD_EDGE_TYPE_LUT: [[[u8; 2]; 3]; 4] = [
    // CENTRAL_SPLIT
    [[TWIN_U8, TWIN_U8], [TWIN_U8, TWIN_U8], [NEXT_U8, PREV_U8]],
    // RIGHT_DOUBLE_SPLIT
    [[NEXT_U8, PREV_U8], [TWIN_U8, TWIN_U8], [NEXT_U8, TWIN_U8]],
    // LEFT_DOUBLE_SPLIT
    [[TWIN_U8, TWIN_U8], [NEXT_U8, PREV_U8], [TWIN_U8, PREV_U8]],
    // TRIPLE_SPLIT
    [[NEXT_U8, PREV_U8], [NEXT_U8, PREV_U8], [TWIN_U8, TWIN_U8]],
];
// given a split command of the parent and an edge type (NEXT, PREV, or TWIN)

pub fn get_child_edge_types(command: u32, parent_edge_type: usize) -> [u8; 2] {
    return CHILD_EDGE_TYPE_LUT[(command / 2) as usize][parent_edge_type as usize];
}
